#!/bin/bash

set -e

SSH_CONF=~/.ssh
GITHUB_URL="http://github.com/MLabusquiere/hssh"
HEADER="#File generated by $0 at $GITHUB_URL"

#Parse option
FORCE=
DEFAULT_USERNAME=
QUALIFIED_NAME=

usage()	
{
	cat <<-EOF >&2
	USAGE : 
	$0 print (<env>)
	$0 switch <env>
	$0 parse <env_name> <file|-> <suffix_QUALIFIED_NAME> 
	         [ -f -u <default_username> -q <hostname_end> ]
	$0 help|-h|--help

	print  : print the 'env' or list all env name
	switch : will switch the current env to 'env' 
	parse  : will parse the csv and create a new 
	         config file with the name 'env' 
		 -f : override an existing env
		 -u : add to all Host a default username
		 -q : add at the arg at the end of the hostname
	csv format : aliases;hostname;username
	EOF
}

log() 
{
	echo >&2 -- "$@"
}

abort()
{
	STATUS=$1 ; shift
	log "$@"  ; exit $STATUS
}

get_colomn()
{
	echo $2	       |
	cut -f$1 -d';' -
}

get_value()
{
	echo "$1" | 
	cut -d' ' -f2-   
}

print_ssh_template()
{
	cat <<-EOF

	Host @@ALIAS@@
		HostName @@HOSTNAME@@
		UserName @@USERNAME@@
	EOF
	#The extract blank line is necessary to print
}

remove_option_unseted()
{ 
	 sed '/^\s*[a-Z]*\s*$/d'
}

backup_config()
{
	log Backup the config file
	mv "$SSH_CONF/config"{,.$(date +%a%b%Y_%H_%m).bck}
}

################################################
# MAIN FUNCTION
################################################

set_parse_args()
{
	while getopts "fu:q:" OPTION 
	do
		case $OPTION in
			f) FORCE="TRUE" ;;
			u) DEFAULT_USERNAME="$OPTARG" ;;
			q) QUALIFIED_NAME="$OPTARG" ;;
			\?) exit 1;;
		esac
	done
}

csv_to_ssh_config()
{
	while read line
	do
		local alias=$(get_colomn 1 "$line")
		local hostname=$(get_colomn 2 "$line")$QUALIFIED_NAME
		local username=$(get_colomn 3 "$line")

		#Check mandatory colomn
		test -n "$hostname" -a -n "$alias" ||
		abort 1 "The first two colomns are mandatory"

		#Set default
		test -n "$username" || 
		username="$DEFAULT_USERNAME"

		#Print file
		print_ssh_template                 | 
		sed -e "s!@@ALIAS@@!$alias!"       \
		    -e "s!@@HOSTNAME@@!$hostname!" \
		    -e "s!@@USERNAME@@!$username!" |
		remove_option_unseted
	done
}

switch_env()
{
	local env=$1	

	#Backup if necessary
	test -f "$SSH_CONF/config" && 
	backup_config

	test -f $SSH_CONF/config_$env      ||
	abort 1 "The env $env does not exist" 
	
	ln --symbolic --force "$SSH_CONF/config"{_$env,}
}

print_ssh_config_line_to_csv()
{
	local host=
	local hostname=
	local username=
	while read line
	do
		case "$line" in
			Host\ *)
				export host="$(get_value "$line")" ;;
			HostName\ *) 
				export hostname="$(get_value "$line")" ;;
			UserName\ *) 
				export username="$(get_value "$line")" ;;
		esac			
	done 
	echo "$hostname;$host;$username"
}

print_csv_ssh_config_line()
{
	while IFS=';' read hostalias host username
	do
		printf '%-29.29s %-15.15s %-15.15s\n' \
		       "$hostalias" "$host" "$username"
	done
}

print_ssh_config()
{
	tmp_file=$(mktemp)
	cat - > $tmp_file

	egrep "^Host " $tmp_file |
	while read host_name
	do
		sed -n "/$host_name/,/^$/p" $tmp_file |
		print_ssh_config_line_to_csv          |
		print_csv_ssh_config_line
	done
	rm $tmp_file
}

list_env()
{
	find $SSH_CONF -name 'config_*' -exec basename {} \; |
	cut -d_ -f2-	
}

################################################
# MAIN
################################################

case $1 in
	print)  shift
		if [ -n $1 -o ! -e $SSH_CONF/config_$1 ]
		then
			test -e $SSH_CONF/config_$1 ||
			log $1 env does not exist
			list_env 
		else
			cat $SSH_CONF/config_$1 | 
			print_ssh_config 
		fi
		;;
	switch) shift
		switch_env $1
		;;
	parse) 	shift

		set_parse_args "$@"

		if [ -z "$FORCE" ]
		then
			test ! -e "$SSH_CONF/config_$1"                    || 
			abort 1                                            \ 
			   "The given env already exist. Use -f to override it"
		fi
		
		echo > $SSH_CONF/config_$1 "$HEADER"
		cat $2 	          |
		csv_to_ssh_config > "$SSH_CONF/config_$1"     
    		;;
    	help|-h|--help) 
    		usage && exit 0 || exit 1 ;;
	#Dev purpose
	test) 	. sshh_test ;;
      	*)	usage ; exit 1 
esac

